<!DOCTYPE html>
<html lang="en">
	<head>
		<title>nikitakent</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="styles.css">
		<style>
			body { color: #444; background: #000; }
			a { color: #b02F72; }
		</style>
	</head>
	<body>
		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RefractorText } from './js/RefractorText.js';
			import { SceneUtils } from './js/SceneUtils.js';

			let camera, scene, renderer, clock;
			let refractorText, bouncingSphere;

			init();

			async function init() {

				const container = document.getElementById( 'container' );

				clock = new THREE.Clock();

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
				camera.position.set( 0, 75, 400 );

				// Create refractor text using the module
				refractorText = new RefractorText(scene, {
					text: 'abt',
					position: { x: 0, y: 50, z: 0 },
					textPosition: { x: 30, y: 30, z: 0.01 },
					color: 0xcbcbcb,
					textureWidth: 1024,
					textureHeight: 1024
				});

				// Create bouncing sphere using scene utils
				bouncingSphere = SceneUtils.createBouncingSphere(scene);

				// Create concrete walls using scene utils
				SceneUtils.createConcreteWalls(scene);

				// Create lighting using scene utils
				SceneUtils.createLighting(scene, {
					color: 0x7a7a6b,
					intensity: 2.5,
					distance: 250,
					y: 60
				});

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 40, 0 );
				controls.maxDistance = 400;
				controls.minDistance = 10;
				controls.update();

				// Setup refractor text interaction with camera animation
				refractorText.setupInteraction(camera, renderer, () => {
					// Disable controls during animation
					controls.enabled = false;
					
					// Store initial camera position
					const startPosition = camera.position.clone();
					const startTarget = controls.target.clone();
					
					// First target position (extremely close to create "zooming into pixel" effect)
					const firstTargetPosition = new THREE.Vector3(30, 75, 0.01); // Very close to label, moved up Y axis
					const secondTargetPosition = new THREE.Vector3(30, -60, 0.01); // Second target position
					const targetLookAt = new THREE.Vector3(0, 30, 0);
					const targetLookAt2 = new THREE.Vector3(-50, -40, 0);
					
					// Animation variables
					let startTime = performance.now();
					let phase = 1; // Phase 1: initial zoom, Phase 2: second movement
					const firstDuration = 2000; 
					const secondDuration = 2000; 
					
					function animateCamera() {
						const elapsed = performance.now() - startTime;
						
						if (phase === 1) {
							const progress = Math.min(elapsed / firstDuration, 1);
							const eased = 1 - Math.pow(1 - progress, 3);
							
							camera.position.lerpVectors(startPosition, firstTargetPosition, eased);
							const currentTarget = startTarget.clone().lerp(targetLookAt, eased);
							camera.lookAt(currentTarget);
							
							if (progress < 1) {
								requestAnimationFrame(animateCamera);
							} else {
								// First animation complete, pause for 0.5 seconds
								setTimeout(() => {
									phase = 2;
									startTime = performance.now(); // Reset timer for second phase
									animateCamera();
								}, 200);
							}
						} else if (phase === 2) {
							// Second animation phase
							const progress = Math.min(elapsed / secondDuration, 1);
							const eased = 1 - Math.pow(1 - progress, 3);
							
							camera.position.lerpVectors(firstTargetPosition, secondTargetPosition, eased);
							camera.lookAt(targetLookAt2);
							
							if (progress < 1) {
								requestAnimationFrame(animateCamera);
							} else {
								// Second animation complete, fade background to pink
								const fadeOverlay = document.createElement('div');
								fadeOverlay.style.cssText = `
									position: fixed;
									top: 0;
									left: 0;
									width: 100%;
									height: 100%;
									background: #b02F72;
									opacity: 0;
									transition: opacity 3s ease;
									z-index: 9999;
									pointer-events: none;
								`;
								document.body.appendChild(fadeOverlay);
								
								// Trigger fade
								setTimeout(() => {
									fadeOverlay.style.opacity = '1';
									setTimeout(() => {
										window.location.href = '/abt';
									}, 1000);
								}, 50);
							}
						}
					}
					
					animateCamera();
				});

				window.addEventListener( 'resize', onWindowResize );

				// Reset camera when user returns to page (back button)
				document.addEventListener('visibilitychange', function() {
					if (!document.hidden) {
						// Page is visible again, reset camera to initial position
						camera.position.set(0, 75, 400);
						controls.target.set(0, 40, 0);
						controls.enabled = true;
						controls.update();
					}
				});
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				const time = clock.getElapsedTime();

				// Update refractor animation
				refractorText.animate(time);

				// Update animated sphere
				bouncingSphere.animate(time);

				renderer.render( scene, camera );
			}

	</script>

</body>
</html>