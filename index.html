<!DOCTYPE html>
<html lang="en">
	<head>
		<title>nikitakent</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body { color: #444; background: #000; }
			a { color: #b02F72; }
			#perception-box { position: fixed; top: 20px; left: 20px; font-family: monospace; color: #b02F72; }
			.loading-text { font-size: 16px; font-weight: bold; letter-spacing: 2px; text-shadow: 0 0 10px #b02F72; animation: glow 2s ease-in-out infinite alternate; margin-bottom: 20px; }
			.cyber-box { width: 20px; height: 20px; border: 2px solid #b02F72; background: rgba(176,47,114,0.1); box-shadow: 0 0 15px rgba(176,47,114,0.5), inset 0 0 5px rgba(176,47,114,0.3); transition: transform 0.3s ease; }
			@keyframes glow { to { text-shadow: 0 0 20px #b02F72; } }
		</style>
	</head>
	<body>
		<div id="perception-box"><div class="loading-text">PERCEPTION LOADING</div><div class="cyber-box"></div></div>
		<div id="container"></div>
		
		<script>
			const box = document.querySelector('.cyber-box');
			let rotation = 0;
			function rotateBox() {
				rotation += 90;
				box.style.transform = `rotate(${rotation}deg)`;
				setTimeout(rotateBox, 400 + Math.random() * 200);
			}
			rotateBox();
		</script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Refractor } from 'three/addons/objects/Refractor.js';
			import { WaterRefractionShader } from 'three/addons/shaders/WaterRefractionShader.js';
			import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

			let camera, scene, renderer, clock;

			let refractor, smallSphere;

			init();

			async function init() {

				const container = document.getElementById( 'container' );

				clock = new THREE.Clock();

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
				camera.position.set( 0, 75, 400 );

				// refractor

				const refractorGeometry = new THREE.PlaneGeometry( 90, 90 );

				function makeRefractorText(text='REFRACTION')
				{ const c=document.createElement('canvas'); c.width=256; 
				c.height=100; const g=c.getContext('2d'); 
				g.fillStyle='rgba(255,255,255,0.1)'; 
				g.fillRect(0,0,c.width,c.height); 
				g.fillStyle='rgba(255,255,255,0.3)'; 
				g.font='bold 80px "Courier New", "SF Mono", "Monaco", "Inconsolata", "Fira Code", monospace'; 
				g.textAlign='center'; g.textBaseline='middle'; 
				g.fillText(text, c.width/2, c.height/2); const t=new THREE.CanvasTexture(c); t.anisotropy=8; return t; }

				const labelTex = makeRefractorText('abt');
				labelTex.colorSpace = THREE.SRGBColorSpace;

				// Create much smaller geometry just for the text area
				const textGeometry = new THREE.PlaneGeometry(15, 6); // Small area for just the text
				const label = new THREE.Mesh(
				textGeometry,
				new THREE.MeshBasicMaterial({ map: labelTex, transparent: true })
				);
				label.position.set(30, 30, 0.01); 

				refractor = new Refractor( refractorGeometry, {
					color: 0xcbcbcb,
					textureWidth: 1024,
					textureHeight: 1024,
					shader: WaterRefractionShader
				} );

				// Apply text texture to refractor
				// refractor.material.uniforms.tDiffuse.value = label;

				refractor.position.set( 0, 50, 0 );

				scene.add( refractor );
				refractor.add(label);

				// load dudv map for distortion effect
				// Note: Added error handling for texture loading
				try {
					const loader = new THREE.TextureLoader();
					const dudvMap = await loader.loadAsync( 'textures/waterdudv.jpg' );
					dudvMap.wrapS = dudvMap.wrapT = THREE.RepeatWrapping;
					refractor.material.uniforms.tDudv.value = dudvMap;
				} catch (error) {
					console.warn('Could not load texture: textures/waterdudv.jpg', error);
					// The refractor will work without the texture, just without the distortion effect
				}

				//

				// sphere (unchanged)
				const geometry = new THREE.IcosahedronGeometry(5,0);
				const material = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x333333, flatShading: true });
				smallSphere = new THREE.Mesh(geometry, material);
				scene.add(smallSphere);

				// walls â€” distressed concrete
				const planeGeo = new THREE.PlaneGeometry(100.1, 100.1);
				// enable aoMap
				planeGeo.setAttribute('uv2', new THREE.BufferAttribute(planeGeo.attributes.uv.array, 2));

				const loader = new THREE.TextureLoader();
				const rep = 4;
				const wrap = t => (t.wrapS=t.wrapT=THREE.RepeatWrapping, t.repeat.set(rep,rep), t);

				// Wall textures
				const albedo    = wrap(loader.load('textures/concrete/colour.jpeg'));
				const normalMap = wrap(loader.load('textures/concrete/normal.jpeg'));
				const roughMap  = wrap(loader.load('textures/concrete/roughness.jpeg'));
				const aoMap     = wrap(loader.load('textures/concrete/ao.jpg'));
				albedo.colorSpace = THREE.SRGBColorSpace;

				const concrete = new THREE.MeshStandardMaterial({
				map: albedo, normalMap, roughnessMap: roughMap, aoMap,
				roughness: 1, metalness: 0
				});

				// same material, same geometry, same placements
				const planeTop = new THREE.Mesh(planeGeo, concrete);    planeTop.position.y=100; planeTop.rotateX(Math.PI/2);       scene.add(planeTop);
				const planeBottom = new THREE.Mesh(planeGeo, concrete); planeBottom.rotateX(-Math.PI/2);                            scene.add(planeBottom);
				const planeBack = new THREE.Mesh(planeGeo, concrete);   planeBack.position.set(0,50,-50);                            scene.add(planeBack);
				const planeRight = new THREE.Mesh(planeGeo, concrete);  planeRight.position.set(50,50,0); planeRight.rotateY(-Math.PI/2); scene.add(planeRight);
				const planeLeft = new THREE.Mesh(planeGeo, concrete);   planeLeft.position.set(-50,50,0); planeLeft.rotateY(Math.PI/2);   scene.add(planeLeft);



				// lights
				const mainLight = new THREE.PointLight( 0x7a7a6b, 2.5, 250, 0 );
				mainLight.position.y = 60;
				scene.add( mainLight );

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				// Hide perception box
				const box = document.getElementById('perception-box');
				if (box) {
					setTimeout(() => {
						box.style.transition = 'opacity 0.5s ease';
						box.style.opacity = '0';
						setTimeout(() => box.style.display = 'none', 300);
					}, 800);
				}

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 40, 0 );
				controls.maxDistance = 400;
				controls.minDistance = 10;
				controls.update();

				// Raycaster + mouse
				const raycaster = new THREE.Raycaster();
				const mouse = new THREE.Vector2(1, 1);
				let isHovering = false;

				function onMouseMove(event) {
				const rect = renderer.domElement.getBoundingClientRect();
				mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
				mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);

				// IMPORTANT: use recursive = true if label is a group or has children
				const intersects = raycaster.intersectObject(label, true);

				if (intersects.length > 0) {
					if (!isHovering) {
					isHovering = true;
					label.material.color.set(0xb02f72);
					renderer.domElement.style.cursor = 'pointer';
					}
				} else {
					if (isHovering) {
					isHovering = false;
					label.material.color.set(0xffffff);
					renderer.domElement.style.cursor = 'default';
					}
				}	
				}

				function onMouseClick() {
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObject(label, true);
				if (intersects.length > 0) {
					window.location.href = '/abt';
				}
				}

				renderer.domElement.addEventListener('mousemove', onMouseMove);
				renderer.domElement.addEventListener('click', onMouseClick);


				window.addEventListener( 'resize', onWindowResize );
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = clock.getElapsedTime();

				refractor.material.uniforms.time.value = time;

				smallSphere.position.set(
					Math.cos( time ) * 30,
					Math.abs( Math.cos( time * 2 ) ) * 20 + 5,
					Math.sin( time ) * 30
				);
				smallSphere.rotation.y = ( Math.PI / 2 ) - time;
				smallSphere.rotation.z = time * 8;

				renderer.render( scene, camera );

			}

	</script>

</body>
</html>