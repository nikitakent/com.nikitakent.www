{
  "version": 3,
  "sources": ["../../three/examples/jsm/objects/Refractor.js"],
  "sourcesContent": ["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tQuaternion,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType\n} from 'three';\n\n/**\n * Can be used to create a flat, refractive surface like for special\n * windows or water effects.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link viewportSharedTexture}.\n *\n * ```js\n * const geometry = new THREE.PlaneGeometry( 100, 100 );\n *\n * const refractor = new Refractor( refractorGeometry, {\n * \tcolor: 0xcbcbcb,\n * \ttextureWidth: 1024,\n * \ttextureHeight: 1024\n * } );\n *\n * scene.add( refractor );\n * ```\n *\n * @augments Mesh\n * @three_import import { Refractor } from 'three/addons/objects/Refractor.js';\n */\nclass Refractor extends Mesh {\n\n\t/**\n\t * Constructs a new refractor.\n\t *\n\t * @param {BufferGeometry} geometry - The refractor's geometry.\n\t * @param {Refractor~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRefractor = true;\n\n\t\tthis.type = 'Refractor';\n\n\t\t/**\n\t\t * The reflector's virtual camera.\n\t\t *\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Refractor.RefractorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst virtualCamera = this.camera;\n\t\tvirtualCamera.matrixAutoUpdate = false;\n\t\tvirtualCamera.userData.refractor = true;\n\n\t\t//\n\n\t\tconst refractorPlane = new Plane();\n\t\tconst textureMatrix = new Matrix4();\n\n\t\t// render target\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\t// material\n\n\t\tthis.material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t\t} );\n\n\t\tthis.material.uniforms[ 'color' ].value = color;\n\t\tthis.material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\t// functions\n\n\t\tconst visible = ( function () {\n\n\t\t\tconst refractorWorldPosition = new Vector3();\n\t\t\tconst cameraWorldPosition = new Vector3();\n\t\t\tconst rotationMatrix = new Matrix4();\n\n\t\t\tconst view = new Vector3();\n\t\t\tconst normal = new Vector3();\n\n\t\t\treturn function visible( camera ) {\n\n\t\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\n\n\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\t\treturn view.dot( normal ) < 0;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tconst updateRefractorPlane = ( function () {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst position = new Vector3();\n\t\t\tconst quaternion = new Quaternion();\n\t\t\tconst scale = new Vector3();\n\n\t\t\treturn function updateRefractorPlane() {\n\n\t\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\n\t\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\n\n\t\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\t\tnormal.negate();\n\n\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tconst updateVirtualCamera = ( function () {\n\n\t\t\tconst clipPlane = new Plane();\n\t\t\tconst clipVector = new Vector4();\n\t\t\tconst q = new Vector4();\n\n\t\t\treturn function updateVirtualCamera( camera ) {\n\n\t\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\n\t\t\t\tvirtualCamera.matrixWorldInverse.copy( virtualCamera.matrixWorld ).invert();\n\t\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\t\tclipPlane.copy( refractorPlane );\n\t\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\n\n\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\t\tq.z = - 1.0;\n\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t\t// calculate the scaled plane vector\n\n\t\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\n\n\t\t\t\t// replacing the third row of the projection matrix\n\n\t\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\n\t\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\n\t\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\n\t\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t\t// and the model matrix of the refractor\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction render( renderer, scene, camera ) {\n\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t// ensure refractors are rendered only once per frame\n\n\t\t\tif ( camera.userData.refractor === true ) return;\n\n\t\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\t\tif ( ! visible( camera ) === true ) return;\n\n\t\t\t// update\n\n\t\t\tupdateRefractorPlane();\n\n\t\t\tupdateTextureMatrix( camera );\n\n\t\t\tupdateVirtualCamera( camera );\n\n\t\t\trender( renderer, scene, camera );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the reflector's internal render target.\n\t\t *\n\t\t * @return {WebGLRenderTarget} The internal render target\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nRefractor.RefractorShader = {\n\n\tname: 'RefractorShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n\n};\n\n/**\n * Constructor options of `Refractor`.\n *\n * @typedef {Object} Refractor~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The refractor's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the refractive view is projected onto the reflector's geometry.\n * @property {number} [multisample=4] - How many samples to use for MSAA. `0` disables MSAA.\n **/\n\nexport { Refractor };\n"],
  "mappings": "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",
  "names": ["visible", "updateRefractorPlane", "updateVirtualCamera"]
}
