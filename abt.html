<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <title>abt - nikitakent</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    :root { --accent: #b02F72; }
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { width:100%; height:100%; background:var(--accent); font-family:"Gill Sans","Gill Sans MT",sans-serif; overflow:hidden; }
    #refractor-canvas { position:fixed; inset:0; z-index:0; animation:distortIn 4s; }
    #menu-canvas { position:fixed; z-index:2; pointer-events:auto; } /* overlay container */
    .content {
      position:absolute; inset:50% auto auto 50%;
      transform:translate(-50%,-50%); text-align:center; color:#fff;
      max-width:min(90vw,800px); padding:0 5vw; opacity:0; z-index:1; animation:fadeIn 4s ease-out forwards;
    }
    h1 { font-size:clamp(1rem,2vw,1.2rem); font-weight:700; letter-spacing:5px; margin-bottom:1rem; }
    p { font-size:clamp(0.7rem,2.5vw,1rem); font-weight:300; opacity:.9; line-height:1.4; letter-spacing:1px; margin-bottom:1rem; }
    @media (max-width:768px){ .content{padding:0 5vw;} p{margin-bottom:.8rem; line-height:1.3;} }
    @keyframes fadeIn { from{opacity:0; transform:translate(-50%,-50%) scale(1.1); filter:blur(3px);} to{opacity:1; transform:translate(-50%,-50%); filter:none;} }
    @keyframes distortIn { from{opacity:0; transform:scale(1.2) skew(10deg,5deg) rotate(-6deg); filter:blur(10px);} to{opacity:1; transform:none; filter:none;} }
  </style>
</head>
<body>
  <div id="refractor-canvas"></div>

  <div class="content">
    <h1>/abt</h1>
    <p>I use algorithms and game theory to improve markets of any kind. I am particularly interested in internet-based market applications, including high frequency trading, blockchain tokenomics, and improving liquidity in general (sorry, not sorry!!)</p>
    <p>Previously, I was an analyst at Elevation Capital Management and interned at the United Nations secretariat. In 2022, I left New Zealand to pursue a Master's degree in Market Design at the University of Tokyo. In 2024, I wrote my thesis titled "Patent platform shows improvements in social welfare and profits" under the supervision of Prof. Shunya Noda.</p>
    <p>Conferences and government initiatives I have spoken at include the New Zealand parliament, Latin America CAPE, Otago Foreign Policy School, SusHi Tech and the APEC leaders forum.</p>
    <p>Currently I am focussed on product/strategy engineering with AltX Research where I spend my time happily doing a bunch of different things with blockchains, cryptography, stablecoins, and identity in Japan.</p>
  </div>

  <div id="menu-canvas"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "../build/three.module.js",
        "three/addons/": "./jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { Refractor } from 'three/addons/objects/Refractor.js';
    import { WaterRefractionShader } from 'three/addons/shaders/WaterRefractionShader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { SceneUtils } from './js/SceneUtils.js';

    let sceneMain, sceneMenu, cameraMain, cameraMenu, renderer, rendererMenu, clock, refractor, spinningSphere, controls;
    let navMenuGroup, abtLabel, blogLabel, menuVisible = false;

    const vp = { x:0, y:0, w:0, h:0 };
    const DPR = Math.min(2, window.devicePixelRatio || 1);

    init();

    async function init() {
      const container = document.getElementById('refractor-canvas');
      const menuContainer = document.getElementById('menu-canvas');

      sceneMain = new THREE.Scene();
      cameraMain = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 500);
      cameraMain.position.z = 1.8;

      sceneMenu = new THREE.Scene();
      cameraMenu = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 10);
      cameraMenu.position.z = 2;

      clock = new THREE.Clock();

      const refractorGeometry = new THREE.PlaneGeometry(6, 4);
      refractor = new Refractor(refractorGeometry, {
        textureWidth: 512,
        textureHeight: 512,
        shader: WaterRefractionShader
      });
      refractor.position.set(0, 0, 0);
      sceneMain.add(refractor);

      const spherePos = calculateSpherePosition();
      spinningSphere = SceneUtils.createSpinningSphere(sceneMain, spherePos);

      try {
        const dudvMap = await new THREE.TextureLoader().loadAsync('textures/waterdudv.jpg');
        dudvMap.wrapS = dudvMap.wrapT = THREE.RepeatWrapping;
        refractor.material.uniforms.tDudv.value = dudvMap;
      } catch (e) { console.warn('Could not load texture: textures/waterdudv.jpg', e); }

      SceneUtils.createLighting(sceneMain, { color: 0xffffff, intensity: 2.5, distance: 250, y: 60 });

      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setPixelRatio(DPR);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xb02F72, 1);
      renderer.autoClear = true;
      container.appendChild(renderer.domElement);

      rendererMenu = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      rendererMenu.setPixelRatio(DPR);
      rendererMenu.setClearColor(0x000000, 0);
      menuContainer.appendChild(rendererMenu.domElement);

      controls = new OrbitControls(cameraMain, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      createNavMenu();
      bindInteractions();

      onWindowResize();
      updateViewports();
      window.addEventListener('resize', () => { onWindowResize(); updateViewports(); });

      renderer.setAnimationLoop(animate);
    }

    // Slightly larger texture so labels are crisp on phones
    function makeRefractorText(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(255,255,255,1.0)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.font = 'normal 24px "Gill Sans","Gill Sans MT",sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = '#b02F72';
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function createNavMenu() {
      navMenuGroup = new THREE.Group();
      sceneMenu.add(navMenuGroup);

      const makeLabel = (txt, y) => {
        const m = new THREE.Mesh(
          new THREE.PlaneGeometry(0.8, 0.2),
          new THREE.MeshBasicMaterial({ map: makeRefractorText(txt), transparent: true })
        );
        m.position.set(0, y, 0);
        navMenuGroup.add(m);
        return m;
      };

      abtLabel  = makeLabel('/abt',  0.5);
      blogLabel = makeLabel('/blog', -0.5);

      const bg = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 1.5),
        new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25 })
      );
      bg.position.z = -0.01;
      navMenuGroup.add(bg);

      navMenuGroup.visible = false;
    }

    function toggleNavMenu() {
      menuVisible = !menuVisible;
      navMenuGroup.visible = menuVisible;
    }

    function bindInteractions() {
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      const bindPointer = (el, handler) => {
        el.addEventListener('click', handler, { passive: true });
        el.addEventListener('touchstart', (e) => {
          const t = e.touches[0];
          handler({ clientX: t.clientX, clientY: t.clientY, preventDefault:()=>{} });
        }, { passive: true });
      };

      bindPointer(renderer.domElement, (event) => {
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        mouse.set(x, y);
        raycaster.setFromCamera(mouse, cameraMain);
        if (spinningSphere && raycaster.intersectObject(spinningSphere.mesh).length > 0) toggleNavMenu();
      });

      bindPointer(rendererMenu.domElement, (event) => {
        if (!menuVisible) return;
        const rect = rendererMenu.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera({ x, y }, cameraMenu);
        const hits = raycaster.intersectObjects([abtLabel, blogLabel], true);
        if (hits.length) {
          const o = hits[0].object;
          if (o === abtLabel) window.location.href = 'abt.html';
          else if (o === blogLabel) window.location.href = 'blog.html';
        }
      });
    }

    requestAnimationFrame(() => {
      const p = calculateSpherePosition();
      spinningSphere.mesh.position.set(p.x, p.y, p.z);
    });

    // Keep your same intent (50px under .content), but map to world on z=0
    function calculateSpherePosition() {
      const content = document.querySelector('.content');
      const rect = content?.getBoundingClientRect?.() || { bottom: window.innerHeight * 0.6 };

      // Desired screen Y (px), responsive margin
      const margin = window.innerWidth < 768 ? 20 : 50;
      const yPx = Math.min(rect.bottom + margin, window.innerHeight - 50);

      // Screen -> NDC
      const xNdc = 0;
      const yNdc = 1 - (yPx / window.innerHeight) * 2;

      // NDC -> world on z=0
      const ray = new THREE.Raycaster();
      ray.setFromCamera({ x: xNdc, y: yNdc }, cameraMain);
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      const hit = new THREE.Vector3();
      ray.ray.intersectPlane(plane, hit);

      return { x: hit.x, y: hit.y, z: 0.2 };
    }


    function updateViewports() {
      const W = window.innerWidth, H = window.innerHeight;

      renderer.setSize(W, H, false);

      const small = Math.min(W, H) <= 768;
      const s = Math.sqrt(small ? 0.30 : 0.10);
      vp.w = Math.round(W * s);
      vp.h = Math.round(H * s);
      vp.x = Math.floor((W - vp.w) / 2);
      vp.y = Math.floor((H - vp.h) / 2);

      const menuEl = document.getElementById('menu-canvas');
      Object.assign(menuEl.style, { left: vp.x + 'px', top: vp.y + 'px', width: vp.w + 'px', height: vp.h + 'px' });
      rendererMenu.setSize(vp.w, vp.h, false);

      const scale = THREE.MathUtils.clamp(vp.w / 300, 0.8, 1.6);
      navMenuGroup.scale.setScalar(scale);

      cameraMain.aspect = W / H;
      cameraMain.updateProjectionMatrix();
    }

    function onWindowResize() {
      cameraMain.aspect = window.innerWidth / window.innerHeight;
      cameraMain.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (refractor) refractor.scale.setScalar(0.8 * Math.max(cameraMain.aspect, 1));

      if (spinningSphere) {
        const p = calculateSpherePosition();
        spinningSphere.mesh.position.set(p.x, p.y, p.z);
      }
    }

    function animate() {
      const time = clock.getElapsedTime();
      controls?.update();
      if (refractor) refractor.material.uniforms.time.value = time;
      spinningSphere?.animate(time);

      renderer.render(sceneMain, cameraMain);
      rendererMenu.render(sceneMenu, cameraMenu);
    }
  </script>
</body>
</html>
